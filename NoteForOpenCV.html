<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css" integrity="sha384-BTL0nVi8DnMrNdMQZG1Ww6yasK9ZGnUxL1ZWukXQ7fygA1py52yPp9W4wrR00VML" crossorigin="anonymous">
        <style>
/*--------------------------------------------------------------------------------------------- * Copyright (c) Microsoft Corporation. All rights reserved. * Licensed under the MIT License. See License.txt in the project root for license information. *--------------------------------------------------------------------------------------------*/ body { font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback"; font-size: 14px; padding: 0 26px; line-height: 22px; word-wrap: break-word; } #code-csp-warning { position: fixed; top: 0; right: 0; color: white; margin: 16px; text-align: center; font-size: 12px; font-family: sans-serif; background-color:#444444; cursor: pointer; padding: 6px; box-shadow: 1px 1px 1px rgba(0,0,0,.25); } #code-csp-warning:hover { text-decoration: none; background-color:#007acc; box-shadow: 2px 2px 2px rgba(0,0,0,.25); } body.scrollBeyondLastLine { margin-bottom: calc(100vh - 22px); } body.showEditorSelection .code-line { position: relative; } body.showEditorSelection .code-active-line:before, body.showEditorSelection .code-line:hover:before { content: ""; display: block; position: absolute; top: 0; left: -12px; height: 100%; } body.showEditorSelection li.code-active-line:before, body.showEditorSelection li.code-line:hover:before { left: -30px; } .vscode-light.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(0, 0, 0, 0.15); } .vscode-light.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(0, 0, 0, 0.40); } .vscode-light.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-dark.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 255, 255, 0.4); } .vscode-dark.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 255, 255, 0.60); } .vscode-dark.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-high-contrast.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 160, 0, 0.7); } .vscode-high-contrast.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 160, 0, 1); } .vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before { border-left: none; } img { max-width: 100%; max-height: 100%; } a { text-decoration: none; } a:hover { text-decoration: underline; } a:focus, input:focus, select:focus, textarea:focus { outline: 1px solid -webkit-focus-ring-color; outline-offset: -1px; } hr { border: 0; height: 2px; border-bottom: 2px solid; } h1 { padding-bottom: 0.3em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; } h1, h2, h3 { font-weight: normal; } h1 code, h2 code, h3 code, h4 code, h5 code, h6 code { font-size: inherit; line-height: auto; } table { border-collapse: collapse; } table > thead > tr > th { text-align: left; border-bottom: 1px solid; } table > thead > tr > th, table > thead > tr > td, table > tbody > tr > th, table > tbody > tr > td { padding: 5px 10px; } table > tbody > tr + tr > td { border-top: 1px solid; } blockquote { margin: 0 7px 0 5px; padding: 0 16px 0 10px; border-left-width: 5px; border-left-style: solid; } code { font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback"; font-size: 14px; line-height: 19px; } body.wordWrap pre { white-space: pre-wrap; } .mac code { font-size: 12px; line-height: 18px; } pre:not(.hljs), pre.hljs code > div { padding: 16px; border-radius: 3px; overflow: auto; } /** Theming */ pre code { color: var(--vscode-editor-foreground); } .vscode-light pre:not(.hljs), .vscode-light code > div { background-color: rgba(220, 220, 220, 0.4); } .vscode-dark pre:not(.hljs), .vscode-dark code > div { background-color: rgba(10, 10, 10, 0.4); } .vscode-high-contrast pre:not(.hljs), .vscode-high-contrast code > div { background-color: rgb(0, 0, 0); } .vscode-high-contrast h1 { border-color: rgb(0, 0, 0); } .vscode-light table > thead > tr > th { border-color: rgba(0, 0, 0, 0.69); } .vscode-dark table > thead > tr > th { border-color: rgba(255, 255, 255, 0.69); } .vscode-light h1, .vscode-light hr, .vscode-light table > tbody > tr + tr > td { border-color: rgba(0, 0, 0, 0.18); } .vscode-dark h1, .vscode-dark hr, .vscode-dark table > tbody > tr + tr > td { border-color: rgba(255, 255, 255, 0.18); } 
</style>
<style>
/* Tomorrow Theme */ /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */ /* Original theme - https://github.com/chriskempson/tomorrow-theme */ /* Tomorrow Comment */ .hljs-comment, .hljs-quote { color: #8e908c; } /* Tomorrow Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-deletion { color: #c82829; } /* Tomorrow Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-meta, .hljs-link { color: #f5871f; } /* Tomorrow Yellow */ .hljs-attribute { color: #eab700; } /* Tomorrow Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #718c00; } /* Tomorrow Blue */ .hljs-title, .hljs-section { color: #4271ae; } /* Tomorrow Purple */ .hljs-keyword, .hljs-selector-tag { color: #8959a8; } .hljs { display: block; overflow-x: auto; color: #4d4d4c; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }
</style>
<style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
    </head>
    <body>
        <h1 id="opencv学习笔记"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html">OpenCV学习笔记</a></h1>
<ul>
<li><a href="#opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">OpenCV学习笔记</a>
<ul>
<li><a href="#core%E6%A8%A1%E5%9D%97%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD">core模块，核心功能</a>
<ul>
<li><a href="#mat-%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%83%8F%E5%AE%B9%E5%99%A8">MAT-基本图像容器</a></li>
<li><a href="#%E6%89%AB%E6%8F%8F%E5%9B%BE%E5%83%8F%E5%92%8C%E6%9F%A5%E6%89%BE%E8%A1%A8">扫描图像和查找表</a></li>
<li><a href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A9%E7%A0%81%E6%93%8D%E4%BD%9C">矩阵的掩码操作</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E6%B1%82%E5%92%8C">图像求和</a></li>
<li><a href="#%E6%9B%B4%E6%94%B9%E5%AF%B9%E6%AF%94%E5%BA%A6%E4%B8%8E%E4%BA%AE%E5%BA%A6">更改对比度与亮度</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%9B%BE">基本绘图</a></li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8%E4%B8%8E%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97">随机数发生器与绘制文字</a></li>
<li><a href="#%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">离散傅里叶变换</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAxml%E5%92%8Cyaml%E6%96%87%E4%BB%B6">输入输出XML和YAML文件</a></li>
<li><a href="#%E4%B8%8Eopencv-1-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8">与OpenCV 1 同时使用</a></li>
</ul>
</li>
<li><a href="#imgproc%E6%A8%A1%E5%9D%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86">imgproc模块：图像处理</a>
<ul>
<li><a href="#%E5%9B%BE%E5%BD%A2%E5%B9%B3%E6%BB%91%E5%A4%84%E7%90%86">图形平滑处理</a></li>
<li><a href="#%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80">腐蚀与膨胀</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E5%BD%A2%E6%80%81%E5%AD%A6%E5%8F%98%E6%8D%A2">更多形态学变换</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94">图像金字塔</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BD%99%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84opencv%E6%95%99%E7%A8%8B%E7%9B%AE%E5%BD%95">其余较重要的OpenCV教程目录</a>
<ul>
<li><a href="#%E7%BB%99%E5%9B%BE%E5%83%8F%E6%B7%BB%E5%8A%A0%E8%BE%B9%E7%95%8C">给图像添加边界</a></li>
<li><a href="#canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B">Canny边缘检测</a></li>
<li><a href="#%E9%9C%8D%E5%A4%AB%E7%BA%BF%E5%8F%98%E6%8D%A2%E7%94%A8%E4%BA%8E%E6%A3%80%E6%B5%8B%E7%9B%B4%E7%BA%BF">霍夫线变换——用于检测直线</a></li>
<li><a href="#%E9%9C%8D%E5%A4%AB%E5%9C%86%E5%8F%98%E6%8D%A2%E7%94%A8%E4%BA%8E%E6%A3%80%E6%B5%8B%E5%9C%86">霍夫圆变换——用于检测圆</a></li>
<li><a href="#%E9%87%8D%E6%98%A0%E5%B0%84%E7%94%A8%E4%BA%8E%E5%AF%B9%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%8F%98%E6%8D%A2%E5%A6%82%E7%BF%BB%E8%BD%AC%E7%AD%89">重映射——用于对图像进行简单变换，如翻转等</a></li>
<li><a href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E9%AB%98%E7%BA%A7%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2">仿射变换——高级线性变换</a></li>
<li><a href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E5%80%BC%E5%8C%96">直方图均值化</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E6%8A%95%E5%BD%B1">反向投影</a></li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D">模板匹配</a></li>
<li><a href="#%E5%9C%A8%E5%9B%BE%E5%83%8F%E4%B8%AD%E6%A3%80%E6%B5%8B%E8%BD%AE%E5%BB%93">在图像中检测轮廓</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>本笔记为为完成Robocup竞赛中KidSize组而做的OpenCV的学习</p>
<hr>
<p><strong>笔记中各标题均为原教程链接</strong></p>
<p>培训强调内容导航：</p>
<ul>
<li>开闭与顶帽：<a href="#%E6%9B%B4%E5%A4%9A%E5%BD%A2%E6%80%81%E5%AD%A6%E5%8F%98%E6%8D%A2">更多形态学变换</a></li>
<li>直方图均衡：<a href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E5%80%BC%E5%8C%96">直方图均值化</a></li>
<li>掩膜：<a href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A9%E7%A0%81%E6%93%8D%E4%BD%9C">矩阵的掩码操作</a></li>
</ul>
<p>学习建议：先看完<a href="#core%E6%A8%A1%E5%9D%97%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD">core模块，核心功能</a>，再看培训强调内容，最后看其它内容</p>
<hr>
<h2 id="core模块核心功能"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/table_of_content_core/table_of_content_core.html">core模块，核心功能</a></h2>
<h3 id="mat-基本图像容器"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/mat%20-%20the%20basic%20image%20container/mat%20-%20the%20basic%20image%20container.html">MAT-基本图像容器</a></h3>
<p><em>Mat</em>是一个类，由两个数据部分组成：</p>
<ol>
<li><strong>矩阵头</strong>（包含矩阵尺寸，存储方法，存储地址等信息），又称<strong>信息头</strong>；</li>
<li><strong>矩阵指针</strong>，一个指向存储所有像素值的矩阵（根据所选存储方法的不同矩阵可以是不同的维数）的指针，为<strong>常数</strong>。</li>
</ol>
<p>在OpenCV中，每个<em>Mat</em>有自己的信息头，但共享同一个矩阵（即矩阵指针指向同一地址）。故复制构造只复制信息头和矩阵指针。</p>
<pre class="hljs"><code><div>Mat A, C;                                 <span class="hljs-comment">// 只创建信息头部分</span>
A = imread(argv[<span class="hljs-number">1</span>], CV_LOAD_IMAGE_COLOR); <span class="hljs-comment">// 这里为矩阵开辟内存</span>

<span class="hljs-function">Mat <span class="hljs-title">B</span><span class="hljs-params">(A)</span></span>;                                 <span class="hljs-comment">// 使用拷贝构造函数</span>

C = A;                                    <span class="hljs-comment">// 赋值运算符</span>
</div></code></pre>
<p>另外，你还可以创建只引用部分数据的信息头：</p>
<pre class="hljs"><code><div><span class="hljs-function">Mat <span class="hljs-title">D</span> <span class="hljs-params">(A, Rect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span> )</span>; <span class="hljs-comment">//引入一个矩形</span>
Mat E = A(Range:all(), Range(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">//只引用边界参数</span>
</div></code></pre>
<p>使用成员函数<code>clone()</code>或<code>copyTo()</code>来复制包括矩阵数据、信息头和矩阵指针的矩阵</p>
<p><em>Mat</em>支持流式输出，但仅限二维矩阵</p>
<p><strong>构造函数</strong>：</p>
<ul>
<li><code>Mat M(行数, 列数, CV_8UC3, Scalar(0,0,255));</code>或<code>Mat M(维数, 各维尺寸矩阵, CV_8UC(1), Scalar(0,0,0))</code></li>
<li><code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>初始化一个纯白矩阵可用<code>Scalar::all(0)</code></li>
</ul>
<p>其余部分参见原教程</p>
<h3 id="扫描图像和查找表"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/how_to_scan_images/how_to_scan_images.html">扫描图像和查找表</a></h3>
<p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/d741bf066ad4641450e60523988450519478814d.png" alt=""></p>
<p>灰度图像矩阵</p>
<p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/154cd030d6aa7d29c35852ac468a3e3e14b882bf.png" alt=""></p>
<p>RGB颜色模型的矩阵</p>
<p><strong>子列的通道顺序为BGR而非RGB！</strong></p>
<p>推荐的查找表赋值方法：</p>
<ol>
<li>高性能法</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function">Mat&amp; <span class="hljs-title">ScanImageAndReduceC</span><span class="hljs-params">(Mat&amp; I, <span class="hljs-keyword">const</span> uchar* <span class="hljs-keyword">const</span> table)</span>
</span>{
    <span class="hljs-comment">// accept only char type matrices</span>
    CV_Assert(I.depth() != <span class="hljs-keyword">sizeof</span>(uchar));     
    <span class="hljs-keyword">int</span> channels = I.channels();
    <span class="hljs-keyword">int</span> nRows = I.rows * channels; 
    <span class="hljs-keyword">int</span> nCols = I.cols;

    <span class="hljs-keyword">if</span> (I.isContinuous())  <span class="hljs-comment">// make sure the memory of the Mat is continuous</span>
    {
        nCols *= nRows;
        nRows = <span class="hljs-number">1</span>;         
    }

    <span class="hljs-keyword">int</span> i,j;
    uchar* p; 
    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; nRows; ++i)
    {
        p = I.ptr&lt;uchar&gt;(i);  <span class="hljs-comment">// get the pointer of the beginning of the row</span>
        <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; nCols; ++j)  <span class="hljs-comment">// scan til the end of the row</span>
        {
            p[j] = table[p[j]];             
        }
    }
    <span class="hljs-keyword">return</span> I; 
}
</div></code></pre>
<p>或使用<em>data</em></p>
<pre class="hljs"><code><div>uchar* p = I.data;

<span class="hljs-keyword">for</span>( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ncol*nrows; ++i)
    *p++ = table[*p];
</div></code></pre>
<ol start="2">
<li>迭代法</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function">Mat&amp; <span class="hljs-title">ScanImageAndReduceIterator</span><span class="hljs-params">(Mat&amp; I, <span class="hljs-keyword">const</span> uchar* <span class="hljs-keyword">const</span> table)</span>
</span>{
    <span class="hljs-comment">// accept only char type matrices</span>
    CV_Assert(I.depth() != <span class="hljs-keyword">sizeof</span>(uchar));     
    
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> channels = I.channels();  <span class="hljs-comment">// figure out if the Mat is grey or coloourful</span>
    <span class="hljs-keyword">switch</span>(channels)
    {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: 
        {
            MatIterator_&lt;uchar&gt; it, end; 
            <span class="hljs-keyword">for</span>( it = I.begin&lt;uchar&gt;(), end = I.end&lt;uchar&gt;(); it != end; ++it)
                *it = table[*it];
            <span class="hljs-keyword">break</span>;
        }
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: 
        {
            MatIterator_&lt;Vec3b&gt; it, end; 
            <span class="hljs-keyword">for</span>( it = I.begin&lt;Vec3b&gt;(), end = I.end&lt;Vec3b&gt;(); it != end; ++it)
            {
                (*it)[<span class="hljs-number">0</span>] = table[(*it)[<span class="hljs-number">0</span>]];
                (*it)[<span class="hljs-number">1</span>] = table[(*it)[<span class="hljs-number">1</span>]];
                (*it)[<span class="hljs-number">2</span>] = table[(*it)[<span class="hljs-number">2</span>]];
            }
        }
    }
    
    <span class="hljs-keyword">return</span> I; 
}
</div></code></pre>
<ol start="3">
<li>返回某像素点数据的On-the-fly地址计算，即<code>at()</code>（以下为灰度的实例）</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function">Mat&amp; <span class="hljs-title">ScanImageAndReduceRandomAccess</span><span class="hljs-params">(Mat&amp; I, <span class="hljs-keyword">const</span> uchar* <span class="hljs-keyword">const</span> table)</span>
</span>{
    <span class="hljs-comment">// accept only char type matrices</span>
    CV_Assert(I.depth() != <span class="hljs-keyword">sizeof</span>(uchar));     

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> channels = I.channels();
    <span class="hljs-keyword">switch</span>(channels)
    {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: 
        {
            <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; I.rows; ++i)
                <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; I.cols; ++j )
                    I.at&lt;uchar&gt;(i,j) = table[I.at&lt;uchar&gt;(i,j)];
            <span class="hljs-keyword">break</span>;
        }
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: 
        {
         Mat_&lt;Vec3b&gt; _I = I;
            
         <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; I.rows; ++i)
            <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; I.cols; ++j )
               {
                   _I(i,j)[<span class="hljs-number">0</span>] = table[_I(i,j)[<span class="hljs-number">0</span>]];
                   _I(i,j)[<span class="hljs-number">1</span>] = table[_I(i,j)[<span class="hljs-number">1</span>]];
                   _I(i,j)[<span class="hljs-number">2</span>] = table[_I(i,j)[<span class="hljs-number">2</span>]];
            }
         I = _I;
         <span class="hljs-keyword">break</span>;
        }
    }
    
    <span class="hljs-keyword">return</span> I;
}
</div></code></pre>
<ol start="4">
<li>核心函数LUT（最被推荐用于实现批量图像元素查找和更改操作图像方法）</li>
</ol>
<pre class="hljs"><code><div>    <span class="hljs-function">Mat <span class="hljs-title">lookUpTable</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">256</span>, CV_8U)</span></span>;
    uchar* p = lookUpTable.data; 
    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i)
        p[i] = table[i];

    LUT(I, lookUpTable, J);  <span class="hljs-comment">// "I" is input, "J" is output</span>
</div></code></pre>
<p><strong>为得到最优速度，最好尝试四种算法后比较</strong></p>
<p><strong>建议：尽量使用OpenCV内置函数，尤其是和Intel PY的LUT函数：)</strong></p>
<h3 id="矩阵的掩码操作"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/mat-mask-operations/mat-mask-operations.html">矩阵的掩码操作</a></h3>
<p>又称：<strong>掩膜</strong>，培训PPT强调内容！</p>
<p>根据掩码矩阵（也作：<em>核</em>）重新计算图像中每个像素的值。掩码矩阵中的值表示近邻像素值（包括该像素自身的值）对新像素值有<strong>多大影响</strong>。从数学观点看，我们用自己设置的权值，对像素邻域内的值做了个<strong>加权平均</strong>。</p>
<p>例如：增强图像对比度：</p>
<ol>
<li>
<p>将掩码矩阵中心元素对齐到要计算的目标像素上；</p>
</li>
<li>
<p>将邻域像素值与相应的掩码矩阵元素值的乘积相加</p>
</li>
<li>
<p>基本方法</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sharpen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Mat&amp; myImage,Mat&amp; Result)</span>
</span>{
    CV_Assert(myImage.depth() == CV_8U);  <span class="hljs-comment">// 异常处理：确保仅接受uchar图像</span>

    Result.create(myImage.size(),myImage.type());  <span class="hljs-comment">// 初始化输出矩阵</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nChannels = myImage.channels();

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span> ; j &lt; myImage.rows<span class="hljs-number">-1</span>; ++j)
    {
        <span class="hljs-keyword">const</span> uchar* previous = myImage.ptr&lt;uchar&gt;(j - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 获取当前行的前一行的指针</span>
        <span class="hljs-keyword">const</span> uchar* current  = myImage.ptr&lt;uchar&gt;(j    );  <span class="hljs-comment">// 获取当前行的指针</span>
        <span class="hljs-keyword">const</span> uchar* next     = myImage.ptr&lt;uchar&gt;(j + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 获取当前行的后一行的指针</span>

        uchar* output = Result.ptr&lt;uchar&gt;(j);  <span class="hljs-comment">// 输出矩阵的指针</span>

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= nChannels;i &lt; nChannels*(myImage.cols<span class="hljs-number">-1</span>); ++i)
        {
            *output++ = saturate_cast&lt;uchar&gt;(<span class="hljs-number">5</span>*current[i] - current[i-nChannels] - current[i+nChannels] - previous[i] - next[i]);  <span class="hljs-comment">// 每次输出后后移输出指针</span>
        }
    }

    <span class="hljs-comment">// 以下将边界点直接置零（因为边界对比度计算时引用了图像外的数据）</span>
    Result.row(<span class="hljs-number">0</span>).setTo(Scalar(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 上边界</span>
    Result.row(Result.rows<span class="hljs-number">-1</span>).setTo(Scalar(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 下边界</span>
    Result.col(<span class="hljs-number">0</span>).setTo(Scalar(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 左边界</span>
    Result.col(Result.cols<span class="hljs-number">-1</span>).setTo(Scalar(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 有边界</span>
}
</div></code></pre>
<ol start="2">
<li>使用滤波器掩码函数</li>
</ol>
<pre class="hljs"><code><div>Mat kern = (Mat_&lt;<span class="hljs-keyword">char</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) &lt;&lt;  <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>,
                               <span class="hljs-number">-1</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-1</span>,
                                <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>);  <span class="hljs-comment">// 掩码矩阵</span>

filter2D(I, K, I.depth(), kern);  <span class="hljs-comment">// 参数分别为：输入图像，输出图像，掩码（，核的中心，在未定义区域的行为）</span>
</div></code></pre>
<h3 id="图像求和"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/adding_images/adding_images.html">图像求和</a></h3>
<p>略</p>
<h3 id="更改对比度与亮度"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html">更改对比度与亮度</a></h3>
<p><em>图像处理算子</em>是带有一幅或多幅输入图像，产生一幅输出图像的函数</p>
<p>图像变换分为：</p>
<ul>
<li>点算子（像素变换）</li>
<li>邻域算子（基于区域）</li>
</ul>
<p><strong>点算子</strong>：</p>
<ul>
<li>在这一类图像处理变换中，仅仅根据输入像素值（有时可加上某些全局信息或参数）计算相应的输出像素值；</li>
<li>这类算子包括<em>亮度</em>和<em>对比度</em>调整 ，以及<em>颜色校正和变换</em>。</li>
</ul>
<p><strong>亮度和对比度调整</strong>常用常数对点进行<em>乘法</em>和<em>加法</em>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>α</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">r(x)={\alpha}e(x)+\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.0037em;">α</span></span><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span>，其中α&gt;0与β称作<em>增益</em>和<em>偏置</em>参数，分别用于控制<em>对比度</em>和<em>亮度</em></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/core/core.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <span class="hljs-comment">// 危险！！</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;  <span class="hljs-comment">// 危险！！</span>

<span class="hljs-keyword">double</span> alpha;  <span class="hljs-comment">// 控制对比度</span>
<span class="hljs-keyword">int</span> beta;  <span class="hljs-comment">// 控制亮度</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv )</span>
</span>{
    <span class="hljs-comment">// 读入用户提供的图像</span>
    Mat image = imread( argv[<span class="hljs-number">1</span>] );
    Mat new_image = Mat::zeros( image.size(), image.type() );  <span class="hljs-comment">// Matlab风格初始化，使图像有原图像的大小与类型，且为空</span>

    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-built_in">cin</span> &gt;&gt; alpha;  <span class="hljs-comment">// alpha应在1.0到3.0之间</span>
    <span class="hljs-built_in">cin</span> &gt;&gt; beta;  <span class="hljs-comment">// beta应在0到100之间</span>

    <span class="hljs-comment">// 执行运算 new_image(i,j) = alpha*image(i,j) + beta</span>
    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; image.rows; y++ )
    {
        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; image.cols; x++ )
        {
            <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">3</span>; c++ )  <span class="hljs-comment">// 分别访问R、G、B</span>
            {
                new_image.at&lt;Vec3b&gt;(y,x)[c] = saturate_cast&lt;uchar&gt;( alpha*( image.at&lt;Vec3b&gt;(y,x)[c] ) + beta );  <span class="hljs-comment">// saturate_cast用于确保结果未超出取值范围，且为整数</span>
            }
        }
    }

    <span class="hljs-comment">// 创建窗口</span>
    namedWindow(<span class="hljs-string">"Original Image"</span>, <span class="hljs-number">1</span>);
    namedWindow(<span class="hljs-string">"New Image"</span>, <span class="hljs-number">1</span>);

    <span class="hljs-comment">// 显示图像</span>
    imshow(<span class="hljs-string">"Original Image"</span>, image);
    imshow(<span class="hljs-string">"New Image"</span>, new_image);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>也可使用<code>image.convertTo(new_image, -1, alpha, beta);</code></p>
<h3 id="基本绘图"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/basic_geometric_drawing/basic_geometric_drawing.html">基本绘图</a></h3>
<p>略</p>
<h3 id="随机数发生器与绘制文字"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/random_generator_and_text/random_generator_and_text.html">随机数发生器与绘制文字</a></h3>
<p>略</p>
<h3 id="离散傅里叶变换"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html">离散傅里叶变换</a></h3>
<p>用于将图像从空间域转换到频域，常用于决定图片中物体的几何方向</p>
<p>略</p>
<h3 id="输入输出xml和yaml文件"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/file_input_output_with_xml_yml/file_input_output_with_xml_yml.html">输入输出XML和YAML文件</a></h3>
<p>略</p>
<h3 id="与opencv-1-同时使用"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.html">与OpenCV 1 同时使用</a></h3>
<p>略</p>
<h2 id="imgproc模块图像处理"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/table_of_content_imgproc/table_of_content_imgproc.html">imgproc模块：图像处理</a></h2>
<h3 id="图形平滑处理"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html#smoothing">图形平滑处理</a></h3>
<p><em>平滑</em>又称<em>模糊</em>，可用于减少噪声等，需使用滤波器</p>
<p><em>线性滤波器</em>最为常用，输出的像素值为输入像素值的加权和</p>
<p>不妨把<em>滤波器</em>想象为一个包含加权系数的窗口，当使用这个滤波器平滑处理图像时，就把这个窗口滑过图像。</p>
<p><strong>归一化快滤波器</strong>：</p>
<ul>
<li>算术平均，即各像素权值相等</li>
<li><code>blur(src, dst, Size(w, h), Point(-1, -1))</code>函数，参数为输入图像，输出图像，内核大小，锚点（被平滑点）位置（为负则取核的中心）</li>
</ul>
<p><strong>高斯滤波器</strong>：</p>
<ul>
<li>将输入数组的各像素与<em>高斯内核</em>卷积，并将卷积和输出</li>
<li>二位高斯函数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>A</mi><mi>e</mi><mfrac><mrow><mo>−</mo><mo>(</mo><mi>x</mi><mo>−</mo><msub><mi>μ</mi><mi>x</mi></msub><msup><mo>)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msubsup><mi>δ</mi><mi>x</mi><mn>2</mn></msubsup></mrow></mfrac><mo>+</mo><mfrac><mrow><mo>−</mo><mo>(</mo><mi>y</mi><mo>−</mo><msub><mi>μ</mi><mi>y</mi></msub><msup><mo>)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msubsup><mi>δ</mi><mi>y</mi><mn>2</mn></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">G_0(x,y)=Ae\frac{-(x-\mu_x)^2}{2\delta^2_x}+\frac{-(y-\mu_y)^2}{2\delta^2_y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6541199999999998em;vertical-align:-0.5451999999999999em;"></span><span class="mord mathit">A</span><span class="mord mathit">e</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.214em;margin-left:-0.03785em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">x</span></span></span><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mathit mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathit mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5451999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.77366em;vertical-align:-0.64242em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.13124em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathit mtight" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.214em;margin-left:-0.03785em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.42488571428571426em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.50732em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mathit mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathit mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.64242em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，其中μ为均值，δ为标准差</li>
<li><code>GaussianBlur(src, dst, Size(w, h), deltaX, deltaY)</code>，参数为输入图像，输出图像，内核大小（w与h须为正奇数，否则将用两个δ来计算内核大小），x、y方向标准方差</li>
</ul>
<p><strong>中值滤波器</strong>：</p>
<ul>
<li>将每个像素用邻域（以当前像素为中心的正方形区域）像素的中值代替</li>
<li><code>medianBlur(src, dst, i)</code>函数，参数为输入图像，输出图像（需与src相同类型），内核大小（须为奇数）</li>
</ul>
<p><strong>双边滤波器</strong>：</p>
<ul>
<li>避免将边缘磨掉</li>
<li>每个邻域像素都有一个权值，权值分为两部分：
<ol>
<li>第一部分与高斯滤波一样</li>
<li>第二部分取决于该邻域像素与当前像素的灰度差值</li>
</ol>
</li>
<li><code>bilateralFilter(src, dst, d, deltaC, deltaS)</code>函数，参数为输入图像，输出图像，邻域直径，颜色空间的标准差，坐标空间的标准差（单位：像素）</li>
</ul>
<p>其余部分参见原教程</p>
<h3 id="腐蚀与膨胀"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html">腐蚀与膨胀</a></h3>
<p><strong>开闭操作即基于此！</strong></p>
<p><strong>形态学操作</strong>：基于形状的一系列图像处理操作。通过将<em>结构元素</em>作用于输入图像来产生输出图像。</p>
<p><em>腐蚀与膨胀</em>是最基本的形态学操作，常用于</p>
<ol>
<li>除噪</li>
<li>分割独立的图像元素，或连接相邻的元素</li>
<li>寻找图片中的明显的极大值区域或极小值区域</li>
</ol>
<p><strong>膨胀</strong>：</p>
<ol>
<li>将图像A与任意形状的内核B（通常为正方形或圆形）进行卷积</li>
<li>内核B有一个可定义的<em>锚点</em>，通常为内核中心</li>
<li>进行膨胀操作时，将内核B划过图像,将内核B覆盖区域的最大像素值提取，并代替锚点位置的像素。显然，这一最大化操作将会导致图像中的<em>亮区</em>开始膨胀</li>
<li>其余参考腐蚀</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dilation</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>* )</span>
</span>{
  <span class="hljs-keyword">int</span> dilation_type;
  <span class="hljs-keyword">if</span>( dilation_elem == <span class="hljs-number">0</span> ){ dilation_type = MORPH_RECT; }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( dilation_elem == <span class="hljs-number">1</span> ){ dilation_type = MORPH_CROSS; }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( dilation_elem == <span class="hljs-number">2</span>) { dilation_type = MORPH_ELLIPSE; }

  Mat element = getStructuringElement( dilation_type,
                                       Size( <span class="hljs-number">2</span>*dilation_size + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>*dilation_size+<span class="hljs-number">1</span> ),
                                       Point( dilation_size, dilation_size ) );
  <span class="hljs-comment">/// 膨胀操作</span>
  dilate( src, dilation_dst, element );
  imshow( <span class="hljs-string">"Dilation Demo"</span>, dilation_dst );
}
</div></code></pre>
<p><strong>腐蚀</strong>：</p>
<ol>
<li>与膨胀恰恰相反，使<em>亮区</em>被腐蚀</li>
<li><code>erode(src, erosion_dst, element)</code>函数，参数为输入图像，输出图像，内核（默认为3*3矩阵）</li>
<li>内核自定义：使用函数<code>getStructuringElement( erosion_type, Size( 2*erosion_size + 1, 2*erosion_size+1 ), Point( erosion_size, erosion_size ) );</code>指定内核为矩形：MORPH_RECT，交叉形：MORPH_CROSS，椭圆形：MORPH_ELLIPSE</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Erosion</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>* )</span>
</span>{
  <span class="hljs-keyword">int</span> erosion_type;
  <span class="hljs-keyword">if</span>( erosion_elem == <span class="hljs-number">0</span> ){ erosion_type = MORPH_RECT; }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( erosion_elem == <span class="hljs-number">1</span> ){ erosion_type = MORPH_CROSS; }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( erosion_elem == <span class="hljs-number">2</span>) { erosion_type = MORPH_ELLIPSE; }

  Mat element = getStructuringElement( erosion_type,
                                       Size( <span class="hljs-number">2</span>*erosion_size + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>*erosion_size+<span class="hljs-number">1</span> ),
                                       Point( erosion_size, erosion_size ) );
  <span class="hljs-comment">/// 腐蚀操作</span>
  erode( src, erosion_dst, element );
  imshow( <span class="hljs-string">"Erosion Demo"</span>, erosion_dst );
}
</div></code></pre>
<h3 id="更多形态学变换"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html">更多形态学变换</a></h3>
<p>培训PPT强调内容！</p>
<p>本部分均可使用<code>morphologyEx()</code>函数，参数为输入图像，输出图像，运算类型，核（一般使用函数<code>getStructuringElement()</code>函数导出内核），锚点位置，迭代次数，边界模式</p>
<p><strong>开运算</strong>：</p>
<ol>
<li>先腐蚀，再膨胀，达到去除小块亮色区域的效果</li>
<li><code>dilate(erode(src, element))</code></li>
<li>参数：MORPH_OPEN</li>
</ol>
<p><strong>闭运算</strong>：</p>
<ol>
<li>先膨胀，再腐蚀，达到去除小块黑洞的效果</li>
<li><code>erode(dilate(src, element))</code></li>
<li>参数：MORPH_CLOSE</li>
</ol>
<p><strong>形态梯度</strong>：</p>
<ol>
<li>膨胀图与腐蚀图之差</li>
<li><code>dilate(src, element) - erode(src, element)</code></li>
<li>参数：MORPH_GRADIENT</li>
</ol>
<p><strong>顶帽</strong>：</p>
<ol>
<li>原图像与开运算结果之差</li>
<li>达到突出比原图轮廓周围更明亮的区域（即被开运算去除的小块亮色）</li>
<li>参数：MORPH_TOPHAT</li>
</ol>
<p><strong>黑帽</strong>：</p>
<ol>
<li>闭运算结果与原图像之差</li>
<li>达到突出比原图轮廓周围更暗的区域，能获得完美的轮廓</li>
<li>参数：MORPH_BLACKHAT</li>
</ol>
<p>另：腐蚀与膨胀可用MORPH_ERODE，MORPH_DILATE参数</p>
<p>示例：</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"opencv2/imgproc/imgproc.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"opencv2/highgui/highgui.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;

<span class="hljs-comment">// 全局变量</span>
Mat src, dst;

<span class="hljs-keyword">int</span> morph_elem = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> morph_size = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> morph_operator = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> max_operator = <span class="hljs-number">4</span>;
<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> max_elem = <span class="hljs-number">2</span>;
<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> max_kernel_size = <span class="hljs-number">21</span>;

<span class="hljs-keyword">char</span>* window_name = <span class="hljs-string">"Morphology Transformations Demo"</span>;

<span class="hljs-comment">// 回调函数申明</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Morphology_Operations</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>* )</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv )</span>
</span>{
 <span class="hljs-comment">// 装载图像</span>
  src = imread( argv[<span class="hljs-number">1</span>] );

  <span class="hljs-keyword">if</span>( !src.data )
  { <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; }

 <span class="hljs-comment">// 创建显示窗口</span>
 namedWindow( window_name, CV_WINDOW_AUTOSIZE );

 <span class="hljs-comment">// 创建选择具体操作的 trackbar</span>
 createTrackbar(<span class="hljs-string">"Operator:\n 0: Opening - 1: Closing \n 2: Gradient - 3: Top Hat \n 4: Black Hat"</span>, window_name, &amp;morph_operator, max_operator, Morphology_Operations );

 <span class="hljs-comment">// 创建选择内核形状的 trackbar</span>
 createTrackbar( <span class="hljs-string">"Element:\n 0: Rect - 1: Cross - 2: Ellipse"</span>, window_name,
                 &amp;morph_elem, max_elem,
                 Morphology_Operations );

 <span class="hljs-comment">// 创建选择内核大小的 trackbar</span>
 createTrackbar( <span class="hljs-string">"Kernel size:\n 2n +1"</span>, window_name,
                 &amp;morph_size, max_kernel_size,
                 Morphology_Operations );

 <span class="hljs-comment">// 启动使用默认值</span>
 Morphology_Operations( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );

 waitKey(<span class="hljs-number">0</span>);
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Morphology_Operations</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>* )</span>
</span>{
  <span class="hljs-comment">// 由于 MORPH_X的取值范围是: 2,3,4,5 和 6</span>
  <span class="hljs-keyword">int</span> operation = morph_operator + <span class="hljs-number">2</span>;

  Mat element = getStructuringElement( morph_elem, Size( <span class="hljs-number">2</span>*morph_size + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>*morph_size+<span class="hljs-number">1</span> ), Point( morph_size, morph_size ) );

  <span class="hljs-comment">// 运行指定形态学操作</span>
  morphologyEx( src, dst, operation, element );
  imshow( window_name, dst );
  }
</div></code></pre>
<h3 id="图像金字塔"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/pyramids/pyramids.html">图像金字塔</a></h3>
<p>用于将图像转换尺寸</p>
<p>略</p>
<h2 id="其余较重要的opencv教程目录">其余较重要的OpenCV教程目录</h2>
<p>由于之后的内容原理比较艰深，偏重应用，故仅放出链接</p>
<h3 id="给图像添加边界"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/copyMakeBorder/copyMakeBorder.html">给图像添加边界</a></h3>
<h3 id="canny边缘检测"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html">Canny边缘检测</a></h3>
<h3 id="霍夫线变换用于检测直线"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/hough_lines/hough_lines.html">霍夫线变换——用于检测直线</a></h3>
<h3 id="霍夫圆变换用于检测圆"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/hough_circle/hough_circle.html">霍夫圆变换——用于检测圆</a></h3>
<h3 id="重映射用于对图像进行简单变换如翻转等"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/remap/remap.html">重映射——用于对图像进行简单变换，如翻转等</a></h3>
<h3 id="仿射变换高级线性变换"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/warp_affine/warp_affine.html">仿射变换——高级线性变换</a></h3>
<h3 id="直方图均值化"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/histogram_equalization/histogram_equalization.html">直方图均值化</a></h3>
<p>直方图表现图像中像素强度的分布，统计了每个强度值所具有的像素个数</p>
<p>直方图均值化即是将各个强度值所具有的像素数尽量的平均</p>
<p><code>equalizeHist(src, dst)</code>函数</p>
<h3 id="反向投影"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/back_projection/back_projection.html">反向投影</a></h3>
<p>根据已得到的某物体的直方图，在新的图像中检测与该物体色调相近的区域</p>
<h3 id="模板匹配"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/template_matching/template_matching.html">模板匹配</a></h3>
<p>在输入图像中寻找与模板图像最相似的区域</p>
<h3 id="在图像中检测轮廓"><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/shapedescriptors/find_contours/find_contours.html">在图像中检测轮廓</a></h3>
<p>接下来就是视频流和机器学习了，恭喜你已经基本掌握了OpenCV中RoboCup很可能用到的部分！</p>

    </body>
    </html>